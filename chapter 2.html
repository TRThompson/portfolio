<DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" type="text/css" href="style.css">
	<link rel="stylesheet" href="w3.css">
	<link rel="stylesheet" href="nav.css">
	<link rel="stylesheet" href="theory.css">
	<title>Chapter 2</title>
	<script src="W3.js"></script>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

</head>

<body>
	<header>
		<h1>Tamzin Thompson</h1>
	</header>
	

	
	<ul class="topnav">
		<li><a href="index.html">Home</a></li>
		<li><a href="personalLife.html">Personal Life</a></li>
		<li><a href="academicLife.html">Academic Life</a></li>
		<li><a href="myProjects.html">My projects</a></li>
		<li><a href="courseContent.html">Course content</a></li>
		<li><a href="contact.html">Contact Me</a></li>
		
	</ul>
	
	<div class="margin">
	
	<h5>Chapter 2 - Elements of Computational thinking<br><br></h5>
	
		KEY TERMS:<br>
		<b> Instruction set:</b>The collection of opcodes a processor is able to decode and execute <br><br>

		KEY POINTS:<br>
		<li> Problem solving can be a disciplined process</li>
		<li> Some problems aren’t solvable</li>
		<li> Some problems are best solved by humans or computers or a partnership of both</li>
		<li> Backtracking can be an effective way of solving sequential problems</li>
		<li> Data mining can show patterns and relationships that aren't immediately obvious. Computer systems have enabled huge data stores to be examined for pattern matching</li>
		<li> Pipelining is a common computing technique that can be applied to everyday problems</li>
		<li> Complex situations can be best explained by visualizations</li>
		<li> Computer systems have enabled the production of strikingly effective visualizations <br></li>
	
		<b> Computational methods: </b> <br><br>

<b>Features that make a problem solvable by computational methods</b><br>

In 1936 Alan Turing devised a theoretical computer based on unlimited memory made from paper tape. Symbols are printed onto the tape and the machine can manipulate the symbol according to a set of rules. Can be used to simulate a computer algorithm - can be used to decide if a problem is computable by testing it against the capabilities of a Turing machine.Any problem that can be solved by a computer today can be solved by a Turing machine - all computers capable of solving same problem if given enough time and memory.
<li> Speed they run at and memory they can access = limiting factors. </li>
<li>The range of problems we can solve with computers is increasing; we have internet, data centres, supercomputers, server farms etc </li>
<li>Joint between humans and computers - some problems will never be solved by computers </li>

<b>Problem Recognition </b><br>
<ul>
<li>Determine exactly what a problem is </li>
<li>Some easier than other to identify</li>
<li>By using computational and intuitive methods may be possible to come up with a (partial) solution</li>

	<b>Backtracking<b>
	<ul>
	<li>Algorithmic approach to a problem where partial solutions to a large problem are built up as a pathway to follow then if the pathway fails the partial solutions are abandoned and the search begins again at the last successful point</li>
	<li>Solving logic problems - sequential problems </li
	</ul>

	<b>Data mining<b>
	<ul>
	<li>Process for trawling through lots of data that comes from many sources</li>
	<li>Find relationships and facts that aren't obvious to a casual observer </li>
	<li>Can be used when data comes from data sets that have different structures - supermarket loyalty card system</li>
	<li> Algorithms that help data mining = ‘pattern matching’ and ‘anomaly detection’</li>
	<li>Possible due to big data bases and fast processing</li>
	<li>Business modeling/planning, disease prevention - certain groups prone to certain disease - show links to lifestyle factors</li>
	</ul>
	
	<b>Performance modelling/b>
	<ul>
	<li>How well a system will perform in real life before it’s implemented </li>
	<li>Not feasible to test all possibilities due to safety, time and expense</li>
	<li>Build models/simulations instead to best predict outcomes</li>
	<li>Performance modelling is only useful as the accuracy of the model and the data that's fed into it</li>
	<li>Statistics: take into account any existing relevant data </li>
	<li>Randomisation: a random function is best way model uncertainty</li>
	</ul>
	
	<b>Pipelining (see chapter 10)</b>
	<ul>
	<li>A situation where the output of one process is the input to another </li>
	<li>Useful in RISC processors where the stages of fetch-decode-execute can be separated. </li>
	</ul>
	
	<b>Visualisation to solve problems <b>
	<ul>
	<li>Used to present data</li>
	<li>Presenting data from a table as a graph</li>
	<li>Can make facts/trends more apparent </li>
	<li>Heat Maps use visualisation as they show the most commonly used paths that cyclists/runners use. The colours show how popular the paths are and by using this information you can gather which is the best route to take as you know if many people use that path then it must be fit for its purpose</li>
	</ul>
</ul>
	
	
<b>Thinking abstractly </b>
<ul>
<li>Abstraction = concept of reality
<li>Abstraction helps us to maximise our chances of solving problems by separating out the components and deciding which ones are important</li>
<li>Variables are abstractions as they represent real word values</li>
<li>Objects are abstraction of real-world things as well as representing other abstractions eg. a chair = a flat surface with 4 legs - it's a concept, a real chair will comply with the abstractions </li>
<li>useful when dealing with a complex system as an abstraction can be used to display the problem and lower-level abstractions can be made to deal with the component parts.</li>
<li>Layering = a way of dividing big systems into separate areas of interest so only necessary connections are made</li>
<li>Details in each layer can be hidden from the others which frees up the solution process to concentrate on one issue at a time/ send different subprograms to different staff/companies to work on </li>
<li>Layering found widely in construction of operating system, databases (chapter 15), networks (chapter 16) and any large system<li>
<li>Means specialisation can make it cheaper and more reliable</li>
<li>Examples: map, simulations </li>
</ul>


<b>Thinking ahead</b>
<ul>
<li>Anticipate what needs to be done in a situation<li>
<li> Inputs and outputs:
	<ul>
	<li>Determine what outputs are needed at the start then work out all necessary inputs</li>
	</ul>
	</li>
<li>Caching:
	<ul>
	<li>Data inputted is stored in RAM in cases it’s needed again, if needed it is easily and quickly accessible</li>
	<li>Prefetching: instruction is requested from memory by the CPU before it’s required - some algorithms can predict what is needed so get data ready in cache to speed up the process</li>
	<li>Example: Oyster card for public transport in pocket rather than bag  </li>
	</ul>
	</li>
	
<b>Preconditions and reusability:</b>
	<ul>
	<li>Separate program modules can be reused in future projects </li>
	<li>Example: Windows DLL (Dynamic Link Library) </li>
	<li>Package of program code that can be called upon to provide certain functionality to a program</li>
	<li>Useful modules accessed again and again by many programs</li>
	<li>Programming languages have extra collections of code for use in certain circumstances - reusing code modules  hence python ‘import’</li>
	</ul>
</ul>
 	</div>

</body>

<footer>
Tamzin Thompson Computing Portfolio<br><br>
North Halifax Grammar School<br>
Moor Bottom Rd <br>
Illingworth <br>
Halifax <br>
HX2 9SU

</footer>

</html>
